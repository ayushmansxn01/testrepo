<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Day 3 | Network Models and HIV/STI with EpiModel | Harvard 2017" />


<title>Tutorial 3: A Different Demographic Approach</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-1.1/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>
<link href="site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">NME HSPH</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://epimodel.org/">
    <span class="fa fa-database"></span>
     
    EpiModel
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Tutorial 3: A Different Demographic Approach</h1>
<h4 class="author"><em>Day 3 | Network Models and HIV/STI with EpiModel | Harvard 2017</em></h4>

</div>


<p>In this example, we show how to build in an aging process, age-specific mortality, and a constant growth model for births. This will require one <em>new</em> module function and two <em>replacement</em> module functions, along with the needed parameters.</p>
<pre class="r"><code>library(&quot;EpiModel&quot;)</code></pre>
<div id="developing-modules" class="section level1">
<h1>Developing Modules</h1>
<div id="aging-module" class="section level2">
<h2>Aging Module</h2>
<p>To introduce aging into a model, we need to write a new module function, here called <code>aging</code>, that performs the necessary processes. Writing this illustrates some key requirements of any module added to <code>netsim</code>. First, to describe what the function actually does: at the initial time step in the loop, which is 2 for the reasons noted above, persons in the population are randomly assigned an age between 18 and 49 years. At the subsequent time steps, their age is incremented by one month, as our time unit for the simulation is a month.</p>
<pre class="r"><code>aging &lt;- function(dat, at) {
  
  ## Attributes
  if (at == 2) {
    n &lt;- sum(dat$attr$active == 1)
    dat$attr$age &lt;- sample(18:49, n, replace = TRUE)
  } else {
    dat$attr$age &lt;- dat$attr$age + 1/12
  }
  
  ## Summary statistics
  if (at == 2) {
    dat$epi$meanAge &lt;- rep(mean(dat$attr$age, na.rm = TRUE), 2)
  } else {
    dat$epi$meanAge[at] &lt;- mean(dat$attr$age, na.rm = TRUE)
  }
  
  return(dat)
}</code></pre>
<p>As described above, all of the modules in <code>netsim</code> use the same two functional arguments, <code>dat</code>, and <code>at</code>. The former is the master data object that carries around individual attributes, summary outcomes, and other data to be output at the end of the simulation. All individual-level attributes are saved in the <code>dat</code> object in a sublist called <code>attr</code>. The <code>active</code> vector of attributes is a binary attribute indicating whether each person is active or not. Therefore, <code>n</code> in time step 2 queries the size of the active population so the <code>sample</code> function knows how many ages to produce. Everyone’s age is stored on that <code>attr</code> list in a new vector called <code>age</code>. That vector is modified for everyone at each subsequent time step. We can add summary statistics to any module by saving them onto <code>dat$epi</code>. Here, we create a vector called <code>meanAge</code> at time step 2 that contains the mean of everyone’s age in the population; at time steps 3 and onward, a new summary statistic and appended on that vector.</p>
</div>
<div id="death-module" class="section level2">
<h2>Death Module</h2>
<p>Whereas the aging module defined above is an original process added to <code>netsim</code> that did not exist in built-in models, death already has a module. In this case, we will replace the existing death module for susceptibles with our new one. In the existing module, the probability of death is based on a fixed risk that may vary by disease status; the parameters that control this, <code>ds.rate</code> and <code>di.rate</code> and so on, are input in the parameters set through <code>param.net</code>. Here, we will replace approach with a simple death module that takes advantage of our new age attribute: we will model the probability of death as a nonlinear function of increasing age, like this:</p>
<pre class="r"><code>ages &lt;- 18:49
death.rates &lt;- 1/(70*12 - ages*12)
par(mar = c(3.2, 3.2, 1, 1), mgp = c(2, 1, 0))
plot(ages, death.rates, pch = 20, xlab = &quot;age&quot;, ylab = &quot;Death Risk&quot;)</code></pre>
<p><img src="d3-tut3_files/figure-html/Ex1deathEx-1.png" width="672" /> Since we are using monthly time units, the death rates need to be specified with that same scale. Our life expectancy will be 70 years: each month closer to that age one gets, the risk of death increases. This is not necessarily meant to fit a real-world demographic life table but the age-specific mortality rates generally <em>do</em> follow a similar form.</p>
<p>In our death module, life expectancy will be a variable parameter, with the death rate calculation to be set in the module function. Who dies at any time step will be based on random draws from binomial distributions which probabilities equal to their age-specific risks.</p>
<pre class="r"><code>dfunc &lt;- function(dat, at) {
  
  # Parameters
  idsElig &lt;- which(dat$attr$active == 1)
  nElig &lt;- length(idsElig)
  nDeaths &lt;- 0
  
  # Processes
  if (nElig &gt; 0) {
    ages &lt;- dat$attr$age[idsElig]
    life.expt &lt;- dat$param$life.expt
    death.rates &lt;- pmin(1, 1/(life.expt*12 - ages*12))
    vecDeaths &lt;- which(rbinom(nElig, 1, death.rates) == 1)
    idsDeaths &lt;- idsElig[vecDeaths]
    nDeaths &lt;- length(idsDeaths)
    
    # Update nodal attributes on attr and networkDynamic object
    if (nDeaths &gt; 0) {
      dat$attr$active[idsDeaths] &lt;- 0
      dat$attr$exitTime[idsDeaths] &lt;- at
      dat$nw &lt;- deactivate.vertices(dat$nw, onset = at, terminus = Inf, 
                                    v = idsDeaths, deactivate.edges = TRUE)
    }
  }
  
  # Summary statistics
  if (at == 2) {
    dat$epi$d.flow &lt;- c(0, nDeaths)
  } else {
    dat$epi$d.flow[at] &lt;- nDeaths
  }
  
  return(dat)
}</code></pre>
<p>The IDs of those eligible for the transition are determined by their current value of the active variable, again held in the <code>attr</code> list on <code>dat</code>. If there are any persons eligible, then the process will proceed. The ages of only those eligible are abstracted from the <code>attr</code> list. The life expectancy parameter is queried from the parameter list, <code>param</code>, containing the parameters passed into the model from <code>param.net</code> as described below. An individual death rate is calculated for each person based on their age and that life expectancy. With those rates, a Bernoulli coin flip is performed for each death-eligible person. If there are any deaths, the active attribute must be toggled from 1 to 0 for those people.</p>
<p>Within the network object, located at <code>dat$nw</code>, each of the dying nodes are “deactivated” from the network. This process removes their existing edges, if they are currently within a partnership, and disallows them from having future partnerships. Similar to our aging module, we count the number of deaths that have occurred within the time step and save that as a flow size in the <code>d.flow</code> vector within the <code>epi</code> sublist. At time step 2, that vector is created; at time steps 3 and onward, the summary statistic is appended onto that vector.</p>
</div>
<div id="birth-module" class="section level2">
<h2>Birth Module</h2>
<p>The built-in birth module for <code>netsim</code> simulates the number of new births at each time step as a function of a fixed rate, contained in the <code>b.rate</code> parameter specified in <code>param.net</code>, and the current population size. In the case of bipartite models, it is possible to specify that the size of the first group only should be considered (e.g., in case that mode 1 represents women in the population). In this example, we will use a different approach by using a constant growth model: the size of the population is expected to grow linearly at each time step based on a fixed growth rate at the outset of the simulation. Therefore, the number of new births that must be generated at each time step is the difference between the expected population size and the current population size.</p>
<pre class="r"><code>bfunc &lt;- function(dat, at) {
  
  # Variables
  growth.rate &lt;- dat$param$growth.rate
  exptPopSize &lt;- dat$epi$num[1] * (1 + growth.rate * at)
  n &lt;- network.size(dat$nw)
  tea.status &lt;- dat$control$tea.status
  
  numNeeded &lt;- exptPopSize - sum(dat$attr$active == 1) 
  if (numNeeded &gt; 0) {
    nBirths &lt;- rpois(1, numNeeded)
  } else {
    nBirths &lt;- 0
  }
  if (nBirths &gt; 0) {    
    dat$nw &lt;- add.vertices(dat$nw, nv = nBirths)
    newNodes &lt;- (n + 1):(n + nBirths)
    dat$nw &lt;- activate.vertices(dat$nw, onset = at, terminus = Inf, v = newNodes)
  }
  
  # Update attributes
  if (nBirths &gt; 0) {
    dat$attr$active &lt;- c(dat$attr$active, rep(1, nBirths))
    dat$attr$status &lt;- c(dat$attr$status, rep(&quot;s&quot;, nBirths))  
    dat$attr$infTime &lt;- c(dat$attr$infTime, rep(NA, nBirths))
    dat$attr$entrTime &lt;- c(dat$attr$entrTime, rep(at, nBirths))
    dat$attr$exitTime &lt;- c(dat$attr$exitTime, rep(NA, nBirths))
    dat$attr$age &lt;- c(dat$attr$age, rep(18, nBirths))
    if (tea.status == TRUE) {
      dat$nw &lt;- activate.vertex.attribute(dat$nw, prefix = &quot;testatus&quot;, 
                                          value = 0, onset = at, 
                                          terminus = Inf, v = newNodes)
    }
  }

  # Summary statistics
  if (at == 2) {
    dat$epi$b.flow &lt;- c(0, nBirths)
  } else {
    dat$epi$b.flow[at] &lt;- nBirths
  }
  
  return(dat)
}</code></pre>
<p>As with the life expectancy parameter, the growth rate will be a parameter that we pass into the module function through <code>param.net</code> and which will be stored on <code>dat$param</code>. The expected population size uses that the starting population size, stored in the summary statistics list <code>epi</code>, where the number needed is the difference between the expected and current population size, calculated again with the active attribute on <code>dat</code>.</p>
<p>Any birth function must do two things: add new nodes onto the network object and then update all of their attributes with their initial values. In our function, the <code>add.vertices</code> function will add new nodes onto the network, and the <code>activate.vertices</code> function will allow them to actively form edges within the model. We will need to set the 5 standard attributes for these new incoming births, as well as our new age attribute, on the <code>attr</code> list. The data for the new births will positionally be located at the end of the vector, so we append the values specified above using the <code>c</code> function. So new births will be active, disease susceptible, have no infection time, have an entry time equal to <code>at</code>, have no exit time, and enter the population at age 18. We additionally use a time-varying attribute on the network object for disease status, <code>testatus</code> for temporally-extended status, to track the changes in disease status for each node at each time point. This attribute value will automatically be changed to 1 if the person becomes infected.</p>
</div>
</div>
<div id="model-parameterization" class="section level1">
<h1>Model Parameterization</h1>
<div id="network-model" class="section level2">
<h2>Network Model</h2>
<p>For these examples, we will simplify things by fitting a basic random-mixing model for our ERGM. For the dissolution coefficient adjustment we take the mean of the death rates as a basic approximation to the overall mortality schedule for the population.</p>
<pre class="r"><code>nw &lt;- network.initialize(500, directed = FALSE)
est &lt;- netest(nw, formation = ~edges, target.stats = 150, 
              coef.diss = dissolution_coefs(~offset(edges), 60, mean(death.rates)))</code></pre>
<div id="epidemic-model" class="section level3">
<h3>Epidemic Model</h3>
<p>To parameterize the epidemic model, it is necessary to collect all the new elements that we created. For the model parameters, the transmission modules are unchanged and use the same infection probability and act rate as the built-in models. Our new birth module requires a growth rate parameter. Since our time units are months, we specify a 1% yearly growth rate in terms of monthly growth. The death module requires an input of a life expectancy. The module expects that in terms of years. Initial conditions are specified like a built-in SI model.</p>
<pre class="r"><code>param &lt;- param.net(inf.prob = 0.15, growth.rate = 0.00083, life.expt = 70)
init &lt;- init.net(i.num = 50)</code></pre>
<p>For controls settings, we specify the model type, number of simulations and time steps per simulation, similar to any built-in model. To replace the default death module, it is necessary to input the new <code>dfunc</code> function name as the <code>deaths.FUN</code> parameter. A similar approach is used for the birth module. Both of these functions must be sourced into memory before running <code>control.net</code>: the control function will try to look up this data and save it within the object output. To add a new module into <code>netsim</code>, give the module a name not among those modules available for replacement; but the module name must end with <code>.FUN</code> to register as a module. One important note on ordering: within a time step, replacement modules will be run in the order in which they are listed in the <code>control.net</code> help documentation; additional modules like <code>aging.FUN</code> will be run in the order in which you list them in <code>control.net</code>. Additional modules will run first and existing/replacement modules will run second. This ordering of all the modules may be changed and explicitly specified using the <code>module.order</code> argument in <code>control.net</code>.</p>
<pre class="r"><code>control &lt;- control.net(type = &quot;SI&quot;, nsims = 5, nsteps = 250, 
                       deaths.FUN = dfunc, births.FUN = bfunc, aging.FUN = aging, 
                       depend = TRUE, save.network = FALSE)</code></pre>
<p>Finally, the input for that module argument is the function itself. Because we have not input any parameters that automatically trigger a dependent network model (the vital dynamics parameters), it is necessary to explicitly set that <code>depend=TRUE</code>.</p>
</div>
</div>
</div>
<div id="results" class="section level1">
<h1>Results</h1>
<p>The model is simulated using the standard method of inputting the fitted network model object, the parameters, initial conditions, and control settings.</p>
<pre class="r"><code>mod &lt;- netsim(est, param, init, control)</code></pre>
<p>Printing the model object shows that we now have non-standard birth and death output for flows. Additionally, we have the <code>meanAge</code> data saved as other output (summary statistics saved in <code>epi</code> named ending with <code>.num</code> will automatically be classified as compartments and <code>.flow</code> as flows).</p>
<pre class="r"><code>mod</code></pre>
<pre><code>## EpiModel Simulation
## =======================
## Model class: netsim
## 
## Simulation Summary
## -----------------------
## Model type: SI
## No. simulations: 5
## No. time steps: 250
## No. NW modes: 1
## 
## Model Parameters
## -----------------------
## inf.prob = 0.15
## growth.rate = 0.00083
## life.expt = 70
## act.rate = 1
## 
## Model Output
## -----------------------
## Variables: s.num i.num num meanAge d.flow b.flow si.flow
## Transsmissions: sim1 ... sim5</code></pre>
<p>Basic model plots show the simulation results for the prevalence and absolute state sizes over time. The same sort of graphical plotting options available for any built-in model are also available for these new expansion models.</p>
<pre class="r"><code>par(mfrow = c(1,2))
plot(mod, main = &quot;State Prevalences&quot;)
plot(mod, main = &quot;State Sizes&quot;, sim.lines = TRUE, 
     qnts = FALSE, mean.smooth = FALSE)</code></pre>
<p><img src="d3-tut3_files/figure-html/Ex1plotMod1-1.png" width="672" /></p>
<p>This plot shows the total population size and mean age of the population over time. The linear trend in population size is evidence of our constant growth model. The linear increase in mean age is due to initializing the population at a maximum age of 49 but allowing the life expectancy to reach 70.</p>
<pre class="r"><code>par(mfrow = c(1, 2))
plot(mod, y = &quot;num&quot;, main = &quot;Population Size&quot;, ylim = c(0, 1000))
plot(mod, y = &quot;meanAge&quot;, main = &quot;Mean Age&quot;, ylim = c(18, 70))</code></pre>
<p><img src="d3-tut3_files/figure-html/Ex1plotMod2-1.png" width="672" /></p>
<p>The final plots show the variability and mean number of total deaths and births over time. Setting the quantiles to 1 shows the full extent of the data distribution.</p>
<pre class="r"><code>par(mfrow = c(1, 2))
plot(mod, y = &quot;d.flow&quot;, mean.smooth = TRUE, qnts = 1, main = &quot;Deaths&quot;)
plot(mod, y = &quot;b.flow&quot;, mean.smooth = TRUE, qnts = 1, main = &quot;Births&quot;)</code></pre>
<p><img src="d3-tut3_files/figure-html/Ex1plotMod3-1.png" width="672" /></p>
<br>
<hr style="background-color:#909090;height:1px;width:100%">
<p><small> <em>Last updated:</em> 2017-06-28 with EpiModel v1.5.0 </small></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
